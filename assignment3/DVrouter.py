####################################################
# DVrouter.py
# Name:
# JHED ID:
#####################################################

import sys
from collections import defaultdict
from router import Router
from packet import Packet
import packet
from json import dumps, loads


class DVrouter(Router):
    """Distance vector routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.distance_vector = {} # { destination: { via: cost } }
        self.received_distance_vector = {} # { neighbor: { destination: { via: cost } } }
        self.neighbors = {} # { node: ( port, cost ) }

    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dstAddr in self.distance_vector.keys() and len(self.distance_vector[packet.dstAddr]):
                min_via = min(self.distance_vector[packet.dstAddr], key=self.distance_vector[packet.dstAddr].get)
                self.send(self.neighbors[min_via][0], packet)

        else:
            # Hints: this is a routing packet generated by your routing protocol
            # if the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            # { "src": xx, "dv": {} }
            received_dv = loads(packet.content)
            self.received_distance_vector[received_dv["src"]] = received_dv["dv"]
            self.updateDV()


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # update the distance vector of this router
        # update the forwarding table
        # broadcast the distance vector of this router to neighbors
        self.neighbors[endpoint] = (port, cost)
        if endpoint in self.distance_vector.keys():
            if endpoint not in self.distance_vector[endpoint].keys() or self.distance_vector[endpoint][endpoint] > cost:
                self.distance_vector[endpoint][endpoint] = cost
        else:
            self.distance_vector[endpoint] = {}
            self.distance_vector[endpoint][endpoint] = cost

        self.updateDV()
        self.broadcast(Packet.ROUTING)


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # update the distance vector of this router
        # update the forwarding table
        # broadcast the distance vector of this router to neighbors
        for k, v in self.neighbors.items():
            if v[0] == port:
                self.neighbors.pop(k)

        self.updateDV()
        self.broadcast(Packet.ROUTING)

    def broadcast(self, type):
        print("broadcast: ", self.distance_vector)
        packet_content = dumps({
            'src': self.addr,
            'dv': self.distance_vector
        })
        for addr in self.neighbors.keys():
            packet = Packet(type, self.addr, addr, content=packet_content)
            self.send(self.neighbors[addr][0], packet)


    def updateDV(self):
        # add key to local distance_vector
        self.distance_vector = {}
        for key in self.neighbors.keys():
            self.distance_vector[key] = { key: self.neighbors[key][1] }

        for key in self.neighbors.keys():
            if key not in self.received_distance_vector.keys():
                self.received_distance_vector[key] = {}

        for key in self.received_distance_vector.keys(): # neighbor
            for n_key in self.received_distance_vector[key]: # destination
                if n_key not in self.distance_vector.keys():
                    self.distance_vector[n_key] = {}

        for u in self.distance_vector.keys():
            for v in self.neighbors.keys():
                if u not in self.received_distance_vector[v].keys() or len(self.received_distance_vector[v][u]) == 0:
                    continue
                min_via = min(self.received_distance_vector[v][u], key=self.received_distance_vector[v][u].get)
                if v not in self.distance_vector[u].keys() or self.distance_vector[u][v] > self.neighbors[v][1] \
                     + self.received_distance_vector[v][u][min_via]:
                    self.distance_vector[u][v] = self.neighbors[v][1] + self.received_distance_vector[v][u][min_via]  # this -> v -> u


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # broadcast the distance vector of this router to neighbors
            self.broadcast(Packet.ROUTING)


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return ""
