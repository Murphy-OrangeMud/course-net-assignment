####################################################
# LSrouter.py
# Name: Murphy Cheng
# JHED ID: 1800017781
#####################################################

import sys
from collections import defaultdict

from router import Router
from packet import Packet
from json import dumps, loads

INF = 2e9

# protocol: json {seq_num: xx, src: xx, link_state: dict() }

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.forward_table = {} # dst_addr, (port, cost)
        self.local_link_state = {} # neighbor->(port, cost)
        self.received_link_state = {} # map: node_num->(seq_num, local_link_state)
        self.seq_num = 0


    def handlePacket(self, port, packet):
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dstAddr in self.forward_table.keys():
                self.send(self.forward_table[packet.dstAddr][0], packet)
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            received_link_state = loads(packet.getContent())
            if received_link_state['src'] in self.received_link_state.keys() and \
                received_link_state['seq_num'] <= self.received_link_state[received_link_state['src']][0]:
                return
            self.received_link_state[received_link_state['src']] \
             = (received_link_state['seq_num'], received_link_state['link_state'])
            
            self.updateForwardTable()
            for addr in self.local_link_state.keys():
                if addr == received_link_state['src']:
                    continue
                self.send(self.local_link_state[addr][0], packet)


    def updateForwardTable(self):
        import heapq

        # dijkstra
        q = []
        self.forward_table = {}

        # initialization
        for key in self.local_link_state.keys():
            q.append((self.local_link_state[key][1], key))
            self.forward_table[key] = (self.local_link_state[key][0], self.local_link_state[key][1])

        heapq.heapify(q)
        updated = {}

        while len(q) > 0:
            current_cost, current_key = heapq.heappop(q)
            if current_key not in self.received_link_state.keys():
                self.received_link_state[current_key] = (0, {})
            updated[current_key] = True
            keys = self.received_link_state[current_key][1].keys()
            f_keys = self.forward_table.keys()
            u_keys = updated.keys()
            for k in keys:
                # self.forward_table {addr: (port, cost)}
                if (k not in f_keys) or (self.forward_table[k][1] <= 0) or (self.forward_table[k][0] <= 0) or \
                    (self.forward_table[k][1] >= self.received_link_state[current_key][1][k][1] + current_cost):
                    self.forward_table[k] = (self.forward_table[current_key][0], \
                        self.received_link_state[current_key][1][k][1] + current_cost)
                if k not in u_keys:
                    heapq.heappush(q, (self.forward_table[k][1], k))


    def broadcast(self, type):
        packet_content = dumps({
            'seq_num': self.seq_num,
            'src': self.addr,
            'link_state': self.local_link_state
        })
        for addr in self.local_link_state.keys():
            packet = Packet(type, self.addr, addr, content=packet_content)
            self.send(self.local_link_state[addr][0], packet)


    def handleNewLink(self, port, endpoint, cost):
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        self.local_link_state[endpoint] = (port, cost)
        # self.forward_table[endpoint] = (port, cost)
        self.seq_num += 1
        self.updateForwardTable()
        self.broadcast(Packet.ROUTING)


    def handleRemoveLink(self, port):
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        items = self.local_link_state.items()
        for key, value in items:
            print(key, value)
            if value[0] == port:
                self.local_link_state.pop(key)

        self.seq_num += 1
        self.updateForwardTable()
        self.broadcast(Packet.ROUTING)


    def handleTime(self, timeMillisecs):
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.broadcast(Packet.ROUTING)


    def debugString(self):
        return self.local_link_state
