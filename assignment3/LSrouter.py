####################################################
# LSrouter.py
# Name:
# JHED ID:
#####################################################

import sys
from collections import defaultdict

from router import Router
from packet import Packet
from json import dumps, loads

INF = 2e9

# protocol: json {seq_num: xx, src: xx, link_state: dict() }

class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.forward_table = {} # dst_addr, (path_len, endpoint)
        self.local_link_state = {} # neighbor->(endpoint, path_len, port)
        self.received_link_state = {} # map: node_num->(seq_num, local_link_state)
        self.seq_num = 0


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dstAddr in self.forward_table.keys():
                self.send(self.forward_table[packet.dstAddr][1], packet)
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            received_link_state = loads(packet.getContent())
            # print("Received: ", received_link_state)
            if received_link_state['src'] in self.received_link_state.keys() and \
                received_link_state['seq_num'] <= self.received_link_state[received_link_state['src']][0]:
                return
            self.received_link_state[received_link_state['src']] \
             = (received_link_state['seq_num'], received_link_state['link_state'])
            
            # print("receive: ", self.received_link_state)
            self.updateForwardTable()
            self.broadcast()


    def updateForwardTable(self):
        import heapq
        # print("update: ", self.local_link_state, self.received_link_state)

        # dijkstra
        q = []

        # initialization
        for key in self.local_link_state.keys():
            q.append((self.local_link_state[key][1], key))
            self.forward_table[key] = (self.local_link_state[key][1], self.local_link_state[key][0])
        for key in self.received_link_state.keys():
            if key not in self.local_link_state.keys():
                q.append((INF, key))
            for k in self.received_link_state[key][1].keys():
                q.append((INF, k))

        heapq.heapify(q)

        while len(q) > 0:
            current_cost, current_key = heapq.heappop(q)
            if current_key not in self.received_link_state.keys():
                self.received_link_state[current_key] = (0, {})
            # print(current_key, self.received_link_state[current_key])
            for k in self.received_link_state[current_key][1].keys():
                if k not in self.forward_table.keys() or self.forward_table[k][0] > self.received_link_state[current_key][1][k][1] + current_cost:
                    self.forward_table[k] = (self.received_link_state[current_key][1][k][1] + \
                        current_cost, self.forward_table[current_key][1])
        
        # print("After update: ", self.addr, self.forward_table)


    def broadcast(self):
        packet_content = dumps({
            'seq_num': self.seq_num,
            'src': self.addr,
            'link_state': self.local_link_state
        })
        # print("broadcast: ", packet_content)
        for addr in self.forward_table.keys():
            packet = Packet(Packet.ROUTING, self.addr, addr, content=packet_content)
            self.send(self.forward_table[addr][1], packet)


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        # print("New link: ", self.addr, port, endpoint, cost)
        self.local_link_state[endpoint] = (port, cost)
        self.seq_num += 1
        self.updateForwardTable()
        self.broadcast()


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        items = self.local_link_state.items()
        for key, value in items:
            if value[0] == port:
                self.local_link_state.pop(key)

        self.seq_num += 1
        self.updateForwardTable()
        self.broadcast()


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.broadcast()


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return self.local_link_state
